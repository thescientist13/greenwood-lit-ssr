diff --git a/src/lib/walker-package-ranger.js b/src/lib/walker-package-ranger.js
index 597048716792b6e012df6d617776693be9b57bf8..dad15de7b14fe70bed21cf7f038b25d7668f0d3d 100644
--- a/src/lib/walker-package-ranger.js
+++ b/src/lib/walker-package-ranger.js
@@ -4,7 +4,7 @@ import fs from 'fs';
 const SUPPORTED_EXPORT_CONDITIONS = ['import', 'module-sync', 'default'];
 const IMPORT_MAP_RESOLVED_PREFIX = '/~';
 const importMap = new Map();
-const diagnostics = {};
+const diagnostics = new Map();
 
 function updateImportMap(key, value, resolvedRoot) {
   importMap.set(
@@ -23,7 +23,7 @@ function resolveBareSpecifier(specifier) {
   try {
     resolvedPath = import.meta.resolve(specifier);
   } catch (e) {
-    diagnostics[specifier] = `ERROR (${e.code}): unable to resolve specifier => \`${specifier}\` \n${e.message}`;
+    diagnostics.set(specifier, `ERROR (${e.code}): unable to resolve specifier => \`${specifier}\`\n${e.message}`);
   }
 
   return resolvedPath;
@@ -68,7 +68,9 @@ function derivePackageRoot(resolved) {
     root = root.substring(0, root.lastIndexOf(segment));
   }
 
-  return root;
+  return root !== ''
+    ? root
+    : null;
 }
 
 // helper function to convert export patterns to a regex (thanks ChatGPT :D)
@@ -115,7 +117,9 @@ function patternRoot(pattern) {
  */
 async function walkExportPatterns(dependency, sub, subValue, resolvedRoot) {
   // find the "deepest" segment we can start from to avoid unnecessary file scanning / crawling
+  console.log('walkExportPatterns', { dependency, sub, subValue, resolvedRoot })
   const rootSubValueOffset = patternRoot(subValue);
+  const rootSubValueOffsetLeft = patternRoot(sub);
 
   // ideally we can use fs.glob when it comes out of experimental
   // https://nodejs.org/docs/latest-v22.x/api/fs.html#fspromisesglobpattern-options
@@ -132,12 +136,18 @@ async function walkExportPatterns(dependency, sub, subValue, resolvedRoot) {
         walkDirectoryForExportPatterns(new URL(`./${file}/`, directoryUrl));
       } else if (regexPattern.test(filePathUrl.href)) {
         const relativePath = filePathUrl.href.replace(resolvedRoot, '');
+        console.log({ relativePath });
         // naive way to offset a subValue pattern to the sub pattern
         // ex. "./js/*": "./packages/*/src/index.js",
         // https://unpkg.com/browse/@uswds/uswds@3.10.0/package.json
-        const rootSubRelativePath = relativePath.replace(rootSubValueOffset, '');
-
-        updateImportMap(`${dependency}/${rootSubRelativePath}`, relativePath, resolvedRoot);
+        // as well as find the "holes" in woldcard based subconditions
+        // https://unpkg.com/browse/signal-utils@0.21.1/package.json
+        const rootSubRelativePath = sub.indexOf('*') > 0
+          ? `./${relativePath}`.replace(subValue.split('*')[0], '').replace(subValue.split('*')[1], '')
+          : relativePath.replace(rootSubValueOffset, '');
+        console.log({ dependency, rootSubValueOffset, rootSubRelativePath });
+
+        updateImportMap(`${dependency}${rootSubValueOffsetLeft}/${rootSubRelativePath}`, relativePath, resolvedRoot);
       }
     });
   }
@@ -163,10 +173,12 @@ function trackExportConditions(dependency, exports, sub, condition, resolvedRoot
 // https://nodejs.org/api/packages.html#conditional-exports
 async function walkPackageForExports(dependency, packageJson, resolvedRoot) {
   const { exports, module, main } = packageJson;
-
+  console.log({ dependency, packageJson, resolvedRoot })
   // favor exports over main / module
+  
   if (exports) {
     for (const sub in exports) {
+      console.log({ sub });
       /*
        * test for conditional subpath exports
        * 1. import
@@ -179,14 +191,19 @@ async function walkPackageForExports(dependency, packageJson, resolvedRoot) {
         for (const condition of SUPPORTED_EXPORT_CONDITIONS) {
           if (exports[sub][condition]) {
             matched = true;
-            trackExportConditions(dependency, exports, sub, condition, resolvedRoot);
+            if (sub.indexOf('*') >= 0) {
+              console.log('go walkExportPatterns', { dependency, sub, exports, resolvedRoot })
+              await walkExportPatterns(dependency, sub, exports[sub][condition], resolvedRoot);
+            } else {
+              trackExportConditions(dependency, exports, sub, condition, resolvedRoot);
+            }
             break;
           }
         }
 
         if (!matched) {
           // ex. https://unpkg.com/browse/matches-selector@1.2.0/package.json
-          diagnostics[dependency] = `no supported export conditions (\`${SUPPORTED_EXPORT_CONDITIONS.join(', ')}\`) for dependency => \`${dependency}\``;
+          diagnostics.set(dependency, `no supported export conditions (\`${SUPPORTED_EXPORT_CONDITIONS.join(', ')}\`) for dependency => \`${dependency}\``);
         }
       } else {
         // handle (unconditional) subpath exports
@@ -208,7 +225,7 @@ async function walkPackageForExports(dependency, packageJson, resolvedRoot) {
     updateImportMap(dependency, 'index.js', resolvedRoot);
   } else {
     // ex: https://unpkg.com/browse/uuid@3.4.0/package.json
-    diagnostics[dependency] = `WARNING: No supported entry point detected for => \`${dependency}\``;
+    diagnostics.set(dependency, `WARNING: No supported entry point detected for => \`${dependency}\``);
   }
 }
 
